#include <Arduino.h>
#include <Servo.h>  
#include <PinChangeInterrupt.h>

// ────────────────────────────────────────────────────────────────────────
// 핀 정의
// ────────────────────────────────────────────────────────────────────────
// 채널1(스티어링) PWM 입력 → 디지털 2
// 채널3(스로틀/모터) PWM 입력 → 디지털 3
// 채널5(모드 전환용 스위치) PWM 입력 → 디지털 4
const int rcSteerPin  = 2;  
const int rcMotorPin  = 3;
const int rcModePin   = 4;  // ★ 모드 전환용: AUTO↔MANUAL

// 제어용 출력 핀
const int SERVO_PIN   = 9;   // 서보(조향) PWM 출력
const int ESC_PIN     = 10;  // ESC(모터) PWM 출력
const int LED_LEFT    = 6;   // 수동모드 시 좌회전 LED
const int LED_RIGHT   = 7;   // 수동모드 시 우회전 LED

// ────────────────────────────────────────────────────────────────────────
// RC 입력 변수 (수동 및 모드용)
// ────────────────────────────────────────────────────────────────────────
volatile int         rcSteerPulse   = 1500;  // 채널1 (조향)
volatile int         rcMotorPulse   = 1500;  // 채널3 (스로틀)
volatile int         rcModePulse    = 1500;  // 채널5 (모드 토글)
volatile unsigned long rcSteerStart = 0;
volatile unsigned long rcMotorStart = 0;
volatile unsigned long rcModeStart  = 0;
volatile bool        newRcSteer     = false;
volatile bool        newRcMotor     = false;
volatile bool        newRcMode      = false;

// ────────────────────────────────────────────────────────────────────────
// 자동주행용 변수
// ────────────────────────────────────────────────────────────────────────
int     autoAngle       = 90;    // 0~180 (map → 실제 서보 PWM)
char    autoDir         = 'S';   // 'F'/'B'/'S'
bool    hasNewAutoCmd   = false; // 자동주행 명령 도착 여부 (직접 serial 없이 채널5로 토글만)

// ────────────────────────────────────────────────────────────────────────
// 모드 변수
// ────────────────────────────────────────────────────────────────────────
enum RunMode { AUTO_MODE, MANUAL_MODE };
RunMode currentMode = AUTO_MODE;

// ────────────────────────────────────────────────────────────────────────
// ESC/Servo 보정값
// ────────────────────────────────────────────────────────────────────────
const int STOP_PWM        = 1500;
const int FORWARD_PWM     = 1560;
const int REVERSE_PWM     = 1437;
const int SERVO_PWM_MIN   = 1100;
const int SERVO_PWM_MAX   = 1900;
const int STEER_ANGLE_MIN = 0;
const int STEER_ANGLE_MAX = 180;

// ────────────────────────────────────────────────────────────────────────
// 제어 객체 및 LED 상태
// ────────────────────────────────────────────────────────────────────────
Servo steerServo;
Servo driveESC;

const unsigned long BLINK_INTERVAL = 200;
unsigned long       lastBlinkTime   = 0;
bool                ledLeftState    = LOW;
bool                ledRightState   = LOW;

// ────────────────────────────────────────────────────────────────────────
// 인터럽트 핸들러: 채널1(조향) PWM 측정
// ────────────────────────────────────────────────────────────────────────
void isrRcSteer() {
  if (digitalRead(rcSteerPin) == HIGH) {
    rcSteerStart = micros();
  } else {
    rcSteerPulse = micros() - rcSteerStart;
    newRcSteer   = true;
  }
}

// ────────────────────────────────────────────────────────────────────────
// 인터럽트 핸들러: 채널3(스로틀) PWM 측정
// ────────────────────────────────────────────────────────────────────────
void isrRcMotor() {
  if (digitalRead(rcMotorPin) == HIGH) {
    rcMotorStart = micros();
  } else {
    rcMotorPulse = micros() - rcMotorStart;
    newRcMotor   = true;
  }
}

// ────────────────────────────────────────────────────────────────────────
// 인터럽트 핸들러: 채널5(모드 전환) PWM 측정
// ────────────────────────────────────────────────────────────────────────
void isrRcMode() {
  if (digitalRead(rcModePin) == HIGH) {
    rcModeStart = micros();
  } else {
    rcModePulse = micros() - rcModeStart;
    newRcMode   = true;
  }
}

// ────────────────────────────────────────────────────────────────────────
// setup(): 초기화
// ────────────────────────────────────────────────────────────────────────
void setup() {
  Serial.begin(115200);

  // RC 입력 핀 설정 & 인터럽트 연결
  pinMode(rcSteerPin, INPUT_PULLUP);
  pinMode(rcMotorPin, INPUT_PULLUP);
  pinMode(rcModePin, INPUT_PULLUP);

  attachPinChangeInterrupt(digitalPinToPCINT(rcSteerPin), isrRcSteer, CHANGE);
  attachPinChangeInterrupt(digitalPinToPCINT(rcMotorPin), isrRcMotor, CHANGE);
  attachPinChangeInterrupt(digitalPinToPCINT(rcModePin),  isrRcMode,  CHANGE);

  // 서보 & ESC 초기화
  steerServo.attach(SERVO_PIN);
  driveESC.attach(ESC_PIN);
  steerServo.writeMicroseconds(1500);
  driveESC.writeMicroseconds(STOP_PWM);

  // LED 핀 초기화
  pinMode(LED_LEFT, OUTPUT);
  pinMode(LED_RIGHT, OUTPUT);
  digitalWrite(LED_LEFT, LOW);
  digitalWrite(LED_RIGHT, LOW);

  delay(2000); // 안정화 대기

  // 부트 직후 모드 확정: 채널5를 한 번 읽어서 상태 설정
  // (송신기 전원을 넣고 나서 곧바로 채널5 스위치를 원하는 방향으로 고정해 두면 OK)
  // 만약 RC 송신기/수신기 전원이 아직 안 들어왔으면, loop()에서 첫 newRcMode 이벤트가 들어올 때 업데이트됨.
  currentMode = (rcModePulse > 1500) ? AUTO_MODE : MANUAL_MODE;
  Serial.print("[INIT] 초기 Mode = ");
  Serial.println(currentMode == AUTO_MODE ? "AUTO" : "MANUAL");
}

// ────────────────────────────────────────────────────────────────────────
// loop(): 반복 실행
// ────────────────────────────────────────────────────────────────────────
void loop() {
  // ─── (1) 채널5 모드 전환 감지 ─────────────────────────────────────────
  if (newRcMode) {
    newRcMode = false;
    // rcModePulse 기준절대값이 1500μs를 중심으로 상/하 반전됨
    if (rcModePulse > 1500) {
      // 스위치가 위쪽(폭 >1500) → 자동모드
      if (currentMode != AUTO_MODE) {
        currentMode = AUTO_MODE;
        Serial.println("[MODE] AUTO_MODE 로 전환");
        // 중립 상태로 초기화
        steerServo.writeMicroseconds(1500);
        driveESC.writeMicroseconds(STOP_PWM);
      }
    } else {
      // 스위치가 아래쪽(폭 <1500) → 수동모드
      if (currentMode != MANUAL_MODE) {
        currentMode = MANUAL_MODE;
        Serial.println("[MODE] MANUAL_MODE 로 전환");
        // 중립 상태로 초기화
        steerServo.writeMicroseconds(1500);
        driveESC.writeMicroseconds(STOP_PWM);
      }
    }
  }

  // ─── (2) 자동주행 vs 수동주행 분기 ─────────────────────────────────────
  if (currentMode == AUTO_MODE) {
    // 자동모드: (실전에서는 Python에서 "E:<angle> D:<dir>"를 보내는 경우,
    //            이 예제에서는 hasNewAutoCmd 플래그를 사용하지 않으므로 생략하겠습니다.)
    //
    // 예를 들어, Python 없이 RC 송수신기만으로 자동주행을 하고 싶다면,
    // 여기서 rcSteerPulse와 rcMotorPulse를 사용해서 간단히
    // 전진/후진/좌/우를 구현할 수도 있지만, 이 예제는
    // "RC 모드 스위치로 모드 전환만 하고, 실제 주행 제어(자동알고리즘)는 
    // Python/Flask 쪽에서 E:.. D:.. 명령을 보내는 구조"를 가정합니다.
    //
    // 따라서 이곳에는 별도 코드를 두지 않고, Python에서
    // “E:<angle> D:<dir>\n” 형태로 Serial.write 해줄 때만 실제 ESC/서보가 반응합니다.
    // (hasNewAutoCmd 플래그를 사용하도록 parseCommand()를 추가해도 됩니다.)
    //
    // 다만, 예시 형식으로 “즉시 전진” 같은 간단 자동 동작을 넣고 싶으면 주석을 해제하세요:
    //
    /*
    // (예시) 자동으로 중립 각도(90)에서 전진만 하는 코드:
    steerServo.writeMicroseconds(1500);   // 중앙(90도)
    driveESC.writeMicroseconds(FORWARD_PWM);
    */
    
    // 자동모드에서는 LED 끔
    digitalWrite(LED_LEFT, LOW);
    digitalWrite(LED_RIGHT, LOW);

  } else {
    // 수동모드: RC 송수신기에서 들어오는 PWM을 그대로 ESC/서보에 전달
    if (newRcSteer || newRcMotor) {
      newRcSteer = false;
      newRcMotor = false;
      // (a) 채널1(조향) PWM을 바로 서보에 출력
      int constrainedServo = constrain(rcSteerPulse, 1000, 2000);
      steerServo.writeMicroseconds(constrainedServo);

      // (b) 채널3(스로틀) PWM을 감도 제한(1/5) 후 ESC에 전달
      int motorDev        = rcMotorPulse - 1500;       // -500~+500
      int limitedMotorDev = motorDev / 5;              // -100~+100
      int limitedOut      = 1500 + limitedMotorDev;    // 1400~1600
      int constrainedOut  = constrain(limitedOut, 1000, 2000);
      driveESC.writeMicroseconds(constrainedOut);
    }

    // LED 깜빡이기 (스티어링 방향 표시용)
    int deadband     = 100;
    bool leftActive  = (rcSteerPulse < (1500 - deadband));
    bool rightActive = (rcSteerPulse > (1500 + deadband));
    unsigned long nowMillis = millis();

    if (leftActive) {
      digitalWrite(LED_RIGHT, LOW);
      if (nowMillis - lastBlinkTime >= BLINK_INTERVAL) {
        ledLeftState = !ledLeftState;
        digitalWrite(LED_LEFT, ledLeftState);
        lastBlinkTime = nowMillis;
      }
    }
    else if (rightActive) {
      digitalWrite(LED_LEFT, LOW);
      if (nowMillis - lastBlinkTime >= BLINK_INTERVAL) {
        ledRightState = !ledRightState;
        digitalWrite(LED_RIGHT, ledRightState);
        lastBlinkTime = nowMillis;
      }
    }
    else {
      digitalWrite(LED_LEFT, LOW);
      digitalWrite(LED_RIGHT, LOW);
      ledLeftState  = LOW;
      ledRightState = LOW;
    }
  }

  // 루프 과부하 방지
  delay(5);
}
